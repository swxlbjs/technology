<!DOCTYPE HTML>
<html lang="zh-cn" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>知识就是力量</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="index.html">导语</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">1.</strong> 系统底座</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="system_base/linux/index.html"><strong aria-hidden="true">1.1.</strong> linux</a></li><li class="chapter-item expanded "><a href="system_base/kubernetes/index.html"><strong aria-hidden="true">1.2.</strong> kubernetes</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="system_base/kubernetes/kubernetes_component.html"><strong aria-hidden="true">1.2.1.</strong> kubernetes组件</a></li><li class="chapter-item "><a href="system_base/kubernetes/kubernetes_resource_object.html"><strong aria-hidden="true">1.2.2.</strong> kubernetes资源对象</a></li></ol></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">2.</strong> 算法协议</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="algorithm_protocols/algorithm/index.html"><strong aria-hidden="true">2.1.</strong> 算法</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="algorithm_protocols/algorithm/hash.html"><strong aria-hidden="true">2.1.1.</strong> hash</a></li><li class="chapter-item "><a href="algorithm_protocols/algorithm/sort.html"><strong aria-hidden="true">2.1.2.</strong> sort</a></li></ol></li><li class="chapter-item expanded "><a href="algorithm_protocols/protocols/index.html"><strong aria-hidden="true">2.2.</strong> 协议</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="algorithm_protocols/protocols/grpc.html"><strong aria-hidden="true">2.2.1.</strong> grpc</a></li></ol></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.</strong> 编程语言</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">3.1.</strong> shell</div></li><li class="chapter-item expanded "><a href="programming_language/golang/index.html"><strong aria-hidden="true">3.2.</strong> golang</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="programming_language/golang/keyword.html"><strong aria-hidden="true">3.2.1.</strong> 关键字</a></li><li class="chapter-item "><a href="programming_language/golang/data_type.html"><strong aria-hidden="true">3.2.2.</strong> 数据类型</a></li><li class="chapter-item "><a href="programming_language/golang/source_module.html"><strong aria-hidden="true">3.2.3.</strong> 原生模块</a></li><li class="chapter-item "><a href="programming_language/golang/kubebuilder.html"><strong aria-hidden="true">3.2.4.</strong> kubebuilder</a></li><li class="chapter-item "><a href="programming_language/golang/kubernetes-csi.html"><strong aria-hidden="true">3.2.5.</strong> kubernetes-csi</a></li><li class="chapter-item "><a href="programming_language/golang/question/index.html"><strong aria-hidden="true">3.2.6.</strong> 问题</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="programming_language/golang/question/the_difference_between_array_and_list.html"><strong aria-hidden="true">3.2.6.1.</strong> 数组和列表的区别</a></li></ol></li></ol></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.</strong> 服务组件</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="server_component/activemq/index.html"><strong aria-hidden="true">4.1.</strong> activemq</a></li><li class="chapter-item expanded "><a href="server_component/ceph/index.html"><strong aria-hidden="true">4.2.</strong> ceph</a></li><li class="chapter-item expanded "><a href="server_component/etcd/index.html"><strong aria-hidden="true">4.3.</strong> etcd</a></li><li class="chapter-item expanded "><a href="server_component/kafka/index.html"><strong aria-hidden="true">4.4.</strong> kafka</a></li><li class="chapter-item expanded "><a href="server_component/mongo/index.html"><strong aria-hidden="true">4.5.</strong> mongo</a></li><li class="chapter-item expanded "><a href="server_component/mysql/index.html"><strong aria-hidden="true">4.6.</strong> mysql</a></li><li class="chapter-item expanded "><a href="server_component/rabbitmq/index.html"><strong aria-hidden="true">4.7.</strong> rabbitmq</a></li><li class="chapter-item expanded "><a href="server_component/redis/index.html"><strong aria-hidden="true">4.8.</strong> redis</a></li><li class="chapter-item expanded "><a href="server_component/tdsql/index.html"><strong aria-hidden="true">4.9.</strong> tdsql</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.</strong> 提效工具</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="performance_tools/ansible/index.html"><strong aria-hidden="true">5.1.</strong> ansible</a></li><li class="chapter-item expanded "><a href="performance_tools/jenkins/index.html"><strong aria-hidden="true">5.2.</strong> jenkins</a></li><li class="chapter-item expanded "><a href="performance_tools/kustomize/index.html"><strong aria-hidden="true">5.3.</strong> kustomize</a></li><li class="chapter-item expanded "><a href="performance_tools/mdbook/index.html"><strong aria-hidden="true">5.4.</strong> mdbook</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.</strong> 其他概念</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="conceptual_design/ci_cd/index.html"><strong aria-hidden="true">6.1.</strong> ci/cd</a></li><li class="chapter-item expanded "><a href="conceptual_design/ci_cd/index.html"><strong aria-hidden="true">6.2.</strong> ci/cd</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">知识就是力量</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="导语"><a class="header" href="#导语">导语</a></h1>
<p>持续学习，持续积累</p>
<p>2022/07/24开始，回顾与总结</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="linux"><a class="header" href="#linux">linux</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="kubernetes"><a class="header" href="#kubernetes">kubernetes</a></h1>
<p>Kubernetes 是一个可移植、可扩展的开源平台，用于管理容器化的工作负载和服务，可促进声明式配置和自动化。 Kubernetes 拥有一个庞大且快速增长的生态，其服务、支持和工具的使用范围相当广泛。</p>
<h2 id="kubernetes组件"><a class="header" href="#kubernetes组件">kubernetes组件</a></h2>
<ul>
<li><a href="system_base/kubernetes/kubernetes_component.html#kube-apiserver">kube-apiserver</a></li>
<li><a href="system_base/kubernetes/kubernetes_component.html#etcd">etcd</a></li>
<li><a href="system_base/kubernetes/kubernetes_component.html#kube-scheduler">kube-scheduler</a></li>
<li><a href="system_base/kubernetes/kubernetes_component.html#kube-controller-manager">kube-controller-manager</a></li>
<li><a href="system_base/kubernetes/kubernetes_component.html#cloud-controller-manager">cloud-controller-manager</a></li>
<li><a href="system_base/kubernetes/kubernetes_component.html#kubelet">kubelet</a></li>
<li><a href="system_base/kubernetes/kubernetes_component.html#kube-proxy">kube-proxy</a></li>
</ul>
<h2 id="kubernetes资源对象"><a class="header" href="#kubernetes资源对象">kubernetes资源对象</a></h2>
<ul>
<li>Nodes</li>
<li><a href="system_base/kubernetes/kubernetes_resource_object.html#pods">Pods</a>/Deployments/DaemonSets/StatefulSets/ReplicaSets/Jobs/CronJobs</li>
<li>ConfigMaps/Secrets/HPA</li>
<li>Services/Endpoints/Ingresses</li>
<li>Persistent Volumes Claims/Persistent Volumes/Storage Classes</li>
<li>Namespaces</li>
<li>CRD</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="kubernetes组件-1"><a class="header" href="#kubernetes组件-1">kubernetes组件</a></h1>
<h2 id="kube-apiserver"><a class="header" href="#kube-apiserver">kube-apiserver</a></h2>
<p>API 服务器是 Kubernetes 控制平面的组件， 该组件负责公开了 Kubernetes API，负责处理接受请求的工作。 API 服务器是 Kubernetes 控制平面的前端。</p>
<p>Kubernetes API 服务器的主要实现是 kube-apiserver。 kube-apiserver 设计上考虑了水平扩缩，也就是说，它可通过部署多个实例来进行扩缩。 你可以运行 kube-apiserver 的多个实例，并在这些实例之间平衡流量。</p>
<h2 id="etcd"><a class="header" href="#etcd">etcd</a></h2>
<p>etcd 是兼顾一致性与高可用性的键值数据库，可以作为保存 Kubernetes 所有集群数据的后台数据库。</p>
<p>你的 Kubernetes 集群的 etcd 数据库通常需要有个备份计划。</p>
<h2 id="kube-scheduler"><a class="header" href="#kube-scheduler">kube-scheduler</a></h2>
<p>kube-scheduler 是控制平面的组件， 负责监视新创建的、未指定运行节点（node）的 Pods， 并选择节点来让 Pod 在上面运行。</p>
<p>调度决策考虑的因素包括单个 Pod 及 Pods 集合的资源需求、软硬件及策略约束、 亲和性及反亲和性规范、数据位置、工作负载间的干扰及最后时限。</p>
<h2 id="kube-controller-manager"><a class="header" href="#kube-controller-manager">kube-controller-manager</a></h2>
<p>kube-controller-manager 是控制平面的组件， 负责运行控制器进程。</p>
<p>从逻辑上讲， 每个控制器都是一个单独的进程， 但是为了降低复杂性，它们都被编译到同一个可执行文件，并在同一个进程中运行。</p>
<p>这些控制器包括：</p>
<ul>
<li>节点控制器（Node Controller）：负责在节点出现故障时进行通知和响应</li>
<li>任务控制器（Job Controller）：监测代表一次性任务的 Job 对象，然后创建 Pods 来运行这些任务直至完成</li>
<li>端点控制器（Endpoints Controller）：填充端点（Endpoints）对象（即加入 Service 与 Pod）</li>
<li>服务帐户和令牌控制器（Service Account &amp; Token Controllers）：为新的命名空间创建默认帐户和 API 访问令牌</li>
</ul>
<h2 id="cloud-controller-manager"><a class="header" href="#cloud-controller-manager">cloud-controller-manager</a></h2>
<p>cloud-controller-manager 是指嵌入特定云的控制逻辑之 控制平面组件。 cloud-controller-manager 允许你将你的集群连接到云提供商的 API 之上， 并将与该云平台交互的组件同与你的集群交互的组件分离开来。</p>
<p>cloud-controller-manager 仅运行特定于云平台的控制器。 因此如果你在自己的环境中运行 Kubernetes，或者在本地计算机中运行学习环境， 所部署的集群不需要有云控制器管理器。</p>
<p>与 kube-controller-manager 类似，cloud-controller-manager 将若干逻辑上独立的控制回路组合到同一个可执行文件中， 供你以同一进程的方式运行。</p>
<p>你可以对其执行水平扩容（运行不止一个副本）以提升性能或者增强容错能力。</p>
<p>下面的控制器都包含对云平台驱动的依赖：</p>
<ul>
<li>节点控制器（Node Controller）：用于在节点终止响应后检查云提供商以确定节点是否已被删除</li>
<li>路由控制器（Route Controller）：用于在底层云基础架构中设置路由</li>
<li>服务控制器（Service Controller）：用于创建、更新和删除云提供商负载均衡器</li>
</ul>
<h2 id="kubelet"><a class="header" href="#kubelet">kubelet</a></h2>
<p>kubelet 会在集群中每个节点（node）上运行。 它保证容器（containers）都运行在 Pod 中。</p>
<p>kubelet 接收一组通过各类机制提供给它的 PodSpecs， 确保这些 PodSpecs 中描述的容器处于运行状态且健康。 kubelet 不会管理不是由 Kubernetes 创建的容器。</p>
<h2 id="kube-proxy"><a class="header" href="#kube-proxy">kube-proxy</a></h2>
<p>kube-proxy 是集群中每个节点（node）所上运行的网络代理， 实现 Kubernetes 服务（Service） 概念的一部分。</p>
<p>kube-proxy 维护节点上的一些网络规则， 这些网络规则会允许从集群内部或外部的网络会话与 Pod 进行网络通信。</p>
<p>如果操作系统提供了可用的数据包过滤层，则 kube-proxy 会通过它来实现网络规则。 否则，kube-proxy 仅做流量转发。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="kubernetes资源对象-1"><a class="header" href="#kubernetes资源对象-1">kubernetes资源对象</a></h1>
<h2 id="pods"><a class="header" href="#pods">pods</a></h2>
<ul>
<li>pod 启动流程
<ul>
<li>1、为该 pod 创建一个数据目录
2、从 API Server 读取该 pod 清单
3、为该 pod 挂载外部卷
4、下载 pod 所需的 Secret
5、检查已经运行在节点中 pod，如果该 pod 没有容器或者 Pause 容器没有启动，则先停止pod里所有的容器进程。
6、使用 pause 镜像为每个pod创建一个容器，该容器用于接管 Pod 中所有其他容器的网络。
7、为 pod 中的每个容器做如下处理：为容器计算一个 hash 值，然后用容器的名字去查询对于 docker 容器的 hash 值。若查找到容器，且两者的 hash 值不同，则停止 docker 中容器中进程，并停止与之关联的
pause 容器，若相同，则不做处理。若容器被终止了，且容器没有指定的重启策略，则不做任何处理调用 docker client 下载容器镜像，并启动容器。</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="算法"><a class="header" href="#算法">算法</a></h1>
<h2 id="十大排序算法"><a class="header" href="#十大排序算法">十大排序算法</a></h2>
<p>冒泡排序、桶排序、计数排序、堆排序、插入排序、合并排序、快速排序、基数排序、选择排序、希尔排序</p>
<h2 id="哈希"><a class="header" href="#哈希">哈希</a></h2>
<p>hash冲突的四种解决方法：开放地址、再哈希、链地址、建立公共溢出区</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="哈希-1"><a class="header" href="#哈希-1">哈希</a></h1>
<p>散列、杂凑，或音译为哈希，是把任意长度的输入（又叫做预映射pre-image）通过散列算法变换成固定长度的输出，该输出就是散列值。这种转换是一种压缩映射，也就是，散列值的空间通常远小于输入的空间，不同的输入可能会散列成相同的输出，所以不可能从散列值来确定唯一的输入值。简单的说就是一种将任意长度的消息压缩到某一固定长度的消息摘要的函数。</p>
<h2 id="hash冲突的四种解决方法"><a class="header" href="#hash冲突的四种解决方法">hash冲突的四种解决方法</a></h2>
<p>在计算hash地址的过程中会出现对于不同的关键字出现相同的哈希地址的情况，即key1 ≠ key2，但是f(key1) = f(key2)，这种情况就是Hash 冲突。具有相同关键字的key1和key2称之为同义词。
通过优化哈希函数可以减少这种冲突的情况（如：均衡哈希函数），但是在通用条件下，考虑到于表格的长度有限及关键值（数据）的无限，这种冲突是不可避免的，所以就需要处理冲突。</p>
<p>冲突处理的四种解决方式：</p>
<ul>
<li>开放地址</li>
<li>再哈希</li>
<li>链地址</li>
<li>建立公共溢出区</li>
</ul>
<p>其中开放地址又分为：</p>
<ul>
<li>线性探测再散列</li>
<li>二次探测再散列</li>
<li>伪随机探测再散列</li>
</ul>
<h3 id="开放地址"><a class="header" href="#开放地址">开放地址</a></h3>
<p>开放地址法处理冲突的基本原则就是出现冲突后按照一定算法查找一个空位置存放。公式：</p>
<p>Hi为计算出的地址，H(key)为哈希函数，di为增量。其中di的三种获取方式既是上面提到的开放地址法的三种分类（线性探测再散列、二次探测再散列、伪随机探测再散列）。</p>
<p>线性探测再散列，即依次向后查找</p>
<p>二次探测再散列，即依次向前后查找，增量为1、2、3的二次方。</p>
<p>伪随机探测再散列</p>
<p>伪随机，顾名思义就是随机产生一个增量位移。</p>
<h3 id="再哈希法"><a class="header" href="#再哈希法">再哈希法</a></h3>
<p>再哈希法，就是出现冲突后采用其他的哈希函数计算，直到不再冲突为止。</p>
<p>其中RHi为不同的哈希函数。</p>
<h3 id="链地址法"><a class="header" href="#链地址法">链地址法</a></h3>
<p>链接地址法不同与前两种方法，他是在出现冲突的地方存储一个链表，所有的同义词记录都存在其中。形象点说就行像是在出现冲突的地方直接把后续的值摞上去。例如HashMap，如下图。</p>
<h3 id="建立公共溢出区"><a class="header" href="#建立公共溢出区">建立公共溢出区</a></h3>
<p>建立公共溢出区的基本思想是：假设哈希函数的值域是[1,m-1]，则设向量HashTable[0...m-1]为基本表，每个分量存放一个记录，另外设向量OverTable[0...v]
为溢出表，所有关键字和基本表中关键字为同义词的记录，不管它们由哈希函数得到的哈希地址是什么，一旦发生冲突，都填入溢出表。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="十大排序算法-1"><a class="header" href="#十大排序算法-1">十大排序算法</a></h1>
<h2 id="冒泡排序"><a class="header" href="#冒泡排序">冒泡排序</a></h2>
<p>从左到右，相邻元素进行比较。每次比较一轮，就会找到序列中最大的一个或最小的一个。这个数就会从序列的最右边冒出来。</p>
<p>以从小到大排序为例</p>
<ul>
<li>第一轮比较后，所有数中最大的那个数就会浮到最右边；</li>
<li>第二轮比较后，所有数中第二大的那个数就会浮到倒数第二个位置</li>
<li>就这样一轮一轮地比较，最后实现从小到大排序。</li>
</ul>
<h2 id="桶排序"><a class="header" href="#桶排序">桶排序</a></h2>
<p>分成若干个桶</p>
<ul>
<li>每个桶对应不同的区间</li>
<li>把待排序的数字分别放入相应的桶里面</li>
<li>每个桶里面的数字在进行一次排序（排序方式自己决定）</li>
<li>排序结束后，再依次把每个桶的数字打印出来，桶排序就完成了</li>
</ul>
<h2 id="计数排序"><a class="header" href="#计数排序">计数排序</a></h2>
<ul>
<li>遍历这个无序的随机数组</li>
<li>找出最大值和最小值为，对应的计数范围将是 0 ~ 10</li>
<li>每一个整数按照其值对号入座，对应数组下标的元素进行加1操作</li>
</ul>
<h2 id="堆排序"><a class="header" href="#堆排序">堆排序</a></h2>
<pre><code>func Sort(list []int)  {
length := len(list)
for {
if length &lt; 1 {
break
}
index := length/2 -1
for ;index&gt;=0;index-- {
swap(list, index, length-1)
}
tmp := list[0]
list[0] = list[length - 1]
list[length - 1] = tmp
length--
}
}
func swap(list []int, index int, length int)  {
left := 2*index + 1
right := 2*index + 2
if left &lt;= length &amp;&amp; list[left] &gt; list[index] {
tmp := list[index]
list[index] = list[left]
list[left] = tmp
}
if right &lt;= length &amp;&amp; list[right] &gt; list[index] {
tmp := list[index]
list[index] = list[right]
list[right] = tmp
}
}
</code></pre>
<h2 id="插入排序"><a class="header" href="#插入排序">插入排序</a></h2>
<pre><code>func Sort(list []int, left, right int)  {
for index := left;index &lt;= right;index++ {
if index &gt; 0 {
for i:=index;i&gt;0;i-- {
current := list[i]
pre := list[i-1]
if current &lt;= pre {
utils.SwapGo(list, i, i-1)
} else {
break
}
}
}
}
}
</code></pre>
<h2 id="合并排序"><a class="header" href="#合并排序">合并排序</a></h2>
<pre><code>func Sort(list []int, left, right int) []int{
return mergeSort(list[left:right-left + 1])
}
func mergeSort(list []int) []int {
if len(list) &lt; 2 {
return list
} else {
return merge(mergeSort(list[:len(list)/2]), mergeSort(list[len(list)/2:]))
}
}
func merge(list0, list1 []int) []int{
var result []int
index0 := 0
index1 := 0
for {
if index0 &lt; len(list0) &amp;&amp; index1 &lt; len(list1) {
if list0[index0] &lt; list1[index1] {
result = append(result, list0[index0])
index0 = index0 + 1
} else {
result = append(result, list1[index1])
index1 = index1 + 1
}
} else {
break
}
}
if index0 &lt; len(list0) {
result = append(result, list0[index0:]...)
}
if index1 &lt; len(list1) {
result = append(result, list1[index1:]...)
}
return result
}
</code></pre>
<h2 id="快速排序"><a class="header" href="#快速排序">快速排序</a></h2>
<pre><code>import &quot;github.com/go-algorithm/utils&quot;

func Sort(list []int, left, right int)  {
if right &lt; left {
return
}
flag := list[left]
start := left
end := right
for {
if start == end {
break
}
for list[end] &gt;= flag &amp;&amp; end &gt; start {
end--
}
for list[start] &lt;= flag &amp;&amp; end &gt; start {
start++
}
if end &gt; start {
utils.SwapGo(list, start, end)
}
}
utils.SwapGo(list, left, start)
Sort(list, left, start - 1)
Sort(list, start + 1, right)
}
</code></pre>
<h2 id="基数排序"><a class="header" href="#基数排序">基数排序</a></h2>
<pre><code>func Sort(list []int)  {
baseList := make([][]int, 10)
maxDigist := maxDigist(list)
for i:=0;i&lt;maxDigist;i++ {
for _,value := range list {
baseList[getDigist(value, i)] = append(baseList[getDigist(value, i)], value)
}

        j := 0
        for index,value :=range baseList {
            if len(value) &gt; 0 {
                for _,v := range value {
                    list[j] = v
                    j++
                }
            }
            baseList[index] = nil
        }
    }

}

func maxDigist(list []int) int {
maxDigist := 1
for _,value := range list {
if len(strconv.Itoa(value)) &gt; maxDigist {
maxDigist = len(strconv.Itoa(value))
}
}
return maxDigist
}

func getDigist(number int, index int) int {
strNum := strconv.Itoa(number)
if index &gt; len(strNum) - 1 {
return 0
}
index = len(strNum) - 1 - index
//fmt.Println(&quot;index = &quot;, index)
result,error := strconv.Atoi(string(strNum[index]))
if error != nil {

        return -1
    } else {
        return result
    }

}
</code></pre>
<h2 id="选择排序"><a class="header" href="#选择排序">选择排序</a></h2>
<pre><code>import &quot;github.com/go-algorithm/utils&quot;

func Sort(list []int, left, right int)  {
if left == right {
return
}
minIndex := left
for i:=left;i&lt;=right;i++ {
if list[i] &lt;= list[minIndex] {
minIndex = i
}
}
utils.SwapGo(list, left, minIndex)
Sort(list, left + 1, right)
}
</code></pre>
<h2 id="希尔排序"><a class="header" href="#希尔排序">希尔排序</a></h2>
<pre><code>func Sort(list []int, left, right int)  {
increment := len(list)/3 + 1
for {
if increment &lt; 1 {
break
}
for i:=left;i&lt;increment;i++ {
for j:=i+increment;j&lt;=right;j++ {
if list[j] &lt; list[j-increment] {
tmp := list[j]
list[j] = list[j-increment]
list[j-increment] = tmp
}
}
}
increment--
}
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="协议"><a class="header" href="#协议">协议</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="grpc"><a class="header" href="#grpc">grpc</a></h1>
<h2 id="rpc"><a class="header" href="#rpc">RPC</a></h2>
<p>RPC（Remote Procedure Call）-远程过程调用，他是一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术的协议。RPC 协议包括序列化、协议编解码器和网络传输栈。</p>
<p>RPC采用客户端/服务器模式。请求程序就是一个客户端，而服务提供程序就是一个服务器。首先，客户端调用进程发送一个有进程参数的调用信息到服务进程，然后等待应答信息。在服务器端，进程保持睡眠状态直到调用信息到达为止。当一个调用信息到达，服务器获得进程参数，计算结果，发送答复信息，然后等待下一个调用信息，最后，客户端开启进程接收响应信息，获得进程结果，然后继续执行调用进行。</p>
<h2 id="原理"><a class="header" href="#原理">原理</a></h2>
<ul>
<li>grpc调用原理（底层都是基于http/2的多路复用，都会创建一个stream id）
<ul>
<li>普通 RPC 调用</li>
<li>Streaming 模式服务调用（接收以 err == io.EOF结束）
<ul>
<li>服务端 streaming</li>
<li>客户端 streaming</li>
<li>服务端和客户端双向 streaming</li>
</ul>
</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="golang"><a class="header" href="#golang">golang</a></h1>
<h2 id="关键字"><a class="header" href="#关键字">关键字</a></h2>
<ul>
<li>程序包管理：<a href="programming_language/golang/%E5%85%B3%E9%94%AE%E5%AD%97.html#package">package</a>、<a href="programming_language/golang/%E5%85%B3%E9%94%AE%E5%AD%97.html#import">import</a></li>
<li>实体声明和定义：<a href="programming_language/golang/%E5%85%B3%E9%94%AE%E5%AD%97.html#var">var</a>、<a href="programming_language/golang/%E5%85%B3%E9%94%AE%E5%AD%97.html#const">const</a>、<a href="programming_language/golang/%E5%85%B3%E9%94%AE%E5%AD%97.html#func">func</a>、<a href="programming_language/golang/%E5%85%B3%E9%94%AE%E5%AD%97.html#type">type</a>、<a href="programming_language/golang/%E5%85%B3%E9%94%AE%E5%AD%97.html#struct">struct</a>
、<a href="programming_language/golang/%E5%85%B3%E9%94%AE%E5%AD%97.html#struct">interface</a>、<a href="programming_language/golang/%E5%85%B3%E9%94%AE%E5%AD%97.html#map">map</a>、<a href="programming_language/golang/%E5%85%B3%E9%94%AE%E5%AD%97.html#chan">chan</a></li>
<li>流程控制：<a href="programming_language/golang/%E5%85%B3%E9%94%AE%E5%AD%97.html#go">go</a>、<a href="programming_language/golang/%E5%85%B3%E9%94%AE%E5%AD%97.html#select">select</a>、<a href="programming_language/golang/%E5%85%B3%E9%94%AE%E5%AD%97.html#for">for</a>、<a href="programming_language/golang/%E5%85%B3%E9%94%AE%E5%AD%97.html#range">range</a>、<a href="programming_language/golang/%E5%85%B3%E9%94%AE%E5%AD%97.html#break">break</a>
、<a href="programming_language/golang/%E5%85%B3%E9%94%AE%E5%AD%97.html#continue">continue</a>、<a href="programming_language/golang/%E5%85%B3%E9%94%AE%E5%AD%97.html#if">if</a>、<a href="programming_language/golang/%E5%85%B3%E9%94%AE%E5%AD%97.html#if">else</a>、<a href="programming_language/golang/%E5%85%B3%E9%94%AE%E5%AD%97.html#switch">switch</a>、<a href="programming_language/golang/%E5%85%B3%E9%94%AE%E5%AD%97.html#case">case</a>
、<a href="programming_language/golang/%E5%85%B3%E9%94%AE%E5%AD%97.html#default">default</a>、<a href="programming_language/golang/%E5%85%B3%E9%94%AE%E5%AD%97.html#fallthrough">fallthrough</a>、<a href="programming_language/golang/%E5%85%B3%E9%94%AE%E5%AD%97.html#defer">defer</a>、<a href="programming_language/golang/%E5%85%B3%E9%94%AE%E5%AD%97.html#goto">goto</a>
、<a href="programming_language/golang/%E5%85%B3%E9%94%AE%E5%AD%97.html#return">rutern</a></li>
</ul>
<h2 id="数据类型"><a class="header" href="#数据类型">数据类型</a></h2>
<ul>
<li>基本类型：数字、布尔值、字符串</li>
<li>复合类型：数组、结构体</li>
<li>引用类型：指针、切片、map、函数、通道</li>
<li>接口类型：接口</li>
</ul>
<h2 id="基本知识"><a class="header" href="#基本知识">基本知识</a></h2>
<ul>
<li>
<p><a href="programming_language/golang/index.html#map">map</a></p>
</li>
<li>
<p><a href="programming_language/golang/index.html#context">context</a></p>
</li>
<li>
<p><a href="programming_language/golang/index.html#sync.map">sync.map</a></p>
</li>
</ul>
<p>线程安全</p>
<p>Golang 的 map 在设计之初，就不是用来应对线程安全的，设计团队认为有写并发的需求，但是读的需求更为普遍，不想因为写并发去加入一个锁，从而影响了读需求比较多的使用者的性能。</p>
<p>在查找、赋值、遍历、删除的过程中都会检测写标志，一旦发现写标志置位（等于1），则直接 panic。赋值和删除函数在检测完写标志是复位之后，先将写标志位置位，才会进行之后的操作。</p>
<pre><code>if h.flags&amp;hashWriting == 0 {
throw(&quot;concurrent map writes&quot;)
}


设置写标志：
h.flags |= hashWriting
</code></pre>
<p>关于 map 的底层，它是一个叫 hmap 的结构体，我们可以查看一下源码：（我的 go 版本 1.17）</p>
<p>/在你的 go 目录下 /go/src/runtime/map.go</p>
<p>从这个结构体中，我们可以看出，里面并没有锁相关的字段，像线程安全的数据结构：channel、sync.map ，他们在结构体上就能看到 锁 相关的字段。</p>
<pre><code>type hmap struct {
    // Note: the format of the hmap is also encoded in cmd/compile/internal/reflectdata/reflect.go.
    // Make sure this stays in sync with the compiler's definition.
    count     int // map 的元素数量
    flags     uint8
    B         uint8  // 这是一个对数，怎么理解呢？ len(buckets) = 2^B  （2的B次方）
    noverflow uint16 // overflow 的数量
    hash0     uint32 // 哈希种子，是一个随机值，调用 hash 函数的时候会使用
    buckets    unsafe.Pointer // 指向 buckets 数组的指针
    oldbuckets unsafe.Pointer // 扩容前的 buckets 字段
    nevacuate  uintptr        // 表示扩容进度
    extra *mapextra // 存储溢出桶
}

buckets 字段 里面指向的数据结构为：bmap

type bmap struct {
    tophash [bucketCnt]uint8
}
</code></pre>
<h3 id="context"><a class="header" href="#context">context</a></h3>
<p>context.Context 是golang中独特的涉及,可以用来用来设置截止日期、同步信号，传递请求相关值的结构体。 与 Goroutine 有比较密切的关系。</p>
<p>在web程序中，每个Request都需要开启一个goroutine做一些事情，这些goroutine又可能会开启其他的
goroutine去访问后端资源,比如数据库、RPC服务等,它们需要访问一些共享的资源，比如用户身份信息、认证token、请求截止时间等 这时候可以通过Context，来跟踪这些goroutine，并且通过Context来控制它们，
这就是Go语言为我们提供的Context，中文可以称之为“上下文”。</p>
<ul>
<li>Deadline方法是获取设置的截止时间的意思，第一个返回值是截止时间，到了这个时间点，Context会自动发起取消请求； 第二个返回值ok==false时表示没有设置截止时间，如果需要取消的话，需要调用取消函数进行取消。</li>
<li>Done方法返回一个只读的chan，类型为struct{}，在goroutine中，如果该方法返回的chan可以读取，则意味着parent context已经发起了取消请求，
我们通过Done方法收到这个信号后，就应该做清理操作，然后退出goroutine，释放资源。之后，Err 方法会返回一个错误，告知为什么 Context 被取消。</li>
<li>Err方法返回取消的错误原因，因为什么Context被取消。</li>
<li>Value方法获取该Context上绑定的值，是一个键值对，通过一个Key才可以获取对应的值，这个值一般是线程安全的。</li>
</ul>
<h3 id="syncmap"><a class="header" href="#syncmap">sync.map</a></h3>
<p>sync.map 的结构体如下</p>
<pre><code>type Map struct {
    mu Mutex
    read atomic.Value // readOnly
    dirty map[interface{}]*entry
    misses int
}
</code></pre>
<p>mu: 互斥锁，保护 read 和 dirty
read: 只读数据，指出并发读取 (atomic.Value 类型) 。如果需要更新 read，需要加锁保护数据安全。
read 实际存储的是 readOnly 结构体，内部是一个原生 map，amended 属性用于标记 read 和 dirty 的数据是否一致
dirty: 用来读写数据，这是一个线程不安全的原始 map。包含新写入的 key，并且包含 read 中所有未被删除的 key。
misses: 每次 read 读取失败后，misses 的计数加 1。当达到一定的阈值之后，需要将 dirty 提升为 read，以减少 miss 的情况。</p>
<p>这样通过一个冗余的字段，来支持并发，也算是空间换时间的一种应用吧。</p>
<ul>
<li>
<p>go 并发原理</p>
<ul>
<li>M（thread）、P（processor）、G（goroutine）</li>
<li>G: 代码入口地址、上下文、运行环境</li>
<li>M: 是操作系统层面调度和执行的实体</li>
<li>P: 代表M和G所需要的资源，是对资源的一种抽象管理，P不是一个段代码实体，而是一个管理的数据结构，P主要是降低M对G的复杂性</li>
<li>M和P一一绑定，P默认是CPU核心的数量。M和P的数目差不多</li>
<li>如果没有可用的M，则新建M，然后绑定P和GY运行</li>
</ul>
</li>
<li>
<p>map和sync.map的区别实现原理是啥</p>
<ul>
<li>map 非线性安全，sync.map 加锁线性安全</li>
</ul>
</li>
<li>
<p>context</p>
<ul>
<li>上下文，主要是关联父子任务</li>
</ul>
</li>
<li>
<p>channel 有缓冲和无缓冲 应用场景</p>
<ul>
<li>无缓冲只能一进一出，否则就会阻塞，有缓冲可以存到一定的数量开始才会阻塞</li>
<li>数据流动场景，无缓存channel适用于数据要求同步的场景，而有缓存channel适用于无数据同步的场景。可以根据实现项目需求选择。</li>
<li>停止信号、任务定时、解耦生产方和消费方、控制并发数</li>
<li>使用channel传递结构体的指针而非结构体</li>
</ul>
</li>
<li>
<p>gc</p>
<ul>
<li>触发条件: 1达到定时时间 ，2m interval，2内存大小阈值， 内存达到上次gc后的2倍</li>
<li>垃圾回收，是一种自动内存管理的机制</li>
<li>GO的GC是并行GC, 也就是GC的大部分处理和普通的go代码是同时运行的, 这让GO的GC流程比较复杂。</li>
<li>mark(标记，从根节点开是遍历，标记所有被引用的对象)识别垃圾、sweep(垃圾销毁)、垃圾回收到可用内存管理链表上（freelist）
<ul>
<li>三色标记清理（从根对象出发，不断地把白色对象（可能死亡）一步步标记为灰色（确认存活，还需要扫描）、黑色对象（存活）的过程）
<ul>
<li>白色对象（可能死亡）：未被回收器访问到的对象。在回收开始阶段，所有对象均为白色，当回收结束后，白色对象均不可达。</li>
<li>灰色对象（波面）：已被回收器访问到的对象，但回收器需要对其中的一个或多个指针进行扫描，因为他们可能还指向白色对象。</li>
<li>黑色对象（确定存活）：已被回收器访问到的对象，其中所有字段都已被扫描，黑色对象中任何一个指针都不可能直接指向白色对象。</li>
</ul>
</li>
<li>写屏障(Write Barrier)：当对象新增或更新时，会将其着色为灰色</li>
</ul>
</li>
<li>off 和 stack scan：stw，打开写屏障(Write Barrier)</li>
<li>mark 标记</li>
<li>mark termination 标记结束 stw，关闭写屏障(Write Barrier)，停顿的主要时间</li>
<li>sweep 清理</li>
<li>off</li>
</ul>
</li>
<li>
<p>数据库查询优化</p>
</li>
<li>
<p>mvcc</p>
<ul>
<li>多版本控制</li>
</ul>
</li>
<li>
<p>事物acid</p>
<ul>
<li>原子性： 语句要么都执行，要么都不是执行，是事务最核心的特性，事务本身来说就是以原子性历来定义的，实现主要是基于undo log</li>
<li>持久性： 保证事务提交之后，不会因为宕机等其他的原因而导致数据的丢失，主要是基于 redo log实现</li>
<li>隔离性： 保证事务与事务之间的执行是相互隔离的，事务的执行不会受到其他事务的影响。InnoDB存储引擎默认的数据库隔离级别是 RR ，RR又主要是基于锁机制，数据的隐藏列，undo log类 以及 next-key lock机制</li>
<li>一致性： 事务追求的最终目标，一致性的实现即需要数据库层面的保障，也需要应用层面的保障。</li>
</ul>
</li>
<li>
<p>gc的版本迭代的优化</p>
<ul>
<li>1.7 三色标记
go V1.1</li>
</ul>
</li>
</ul>
<p>程序运行开始。
触发GC。
GC 在需要进入 STW 时，需要通知并让所有的用户态代码停止（stop the world）。
mark(标记)。
sweep(清理)。
start the world。
在这个过程中，gc过程是串行的，stw的时间 = mark时间+ sweep时间</p>
<p>go V1.3版本的优化就是Mark和Sweep分离. Mark STW, Sweep并发。也就是大致变成了一下流程：</p>
<p>程序运行开始。
触发GC。
GC 在需要进入 STW 时，需要通知并让所有的用户态代码停止（stop the world）。
mark。
start the world。
sweep(并发)。
可以看到，这个时候的stw只存在于mark阶段，且sweep清扫阶段变成了并发执行。
go V1.5 再次将mark也变成了并发的。</p>
<p>go1.8 整合插入屏障和删除屏障为混合写屏障，将STW的停顿时间真正进入到毫秒级。</p>
<p>go 1.14：替引入了异步抢占，解决了由于密集循环导致的 STW 时间过长的问题。也就是上文示例所示的因为GC等待用户代码停止时间过长的问题。</p>
<ul>
<li>在追踪式的GC过程中，我们需要进行两步操作，分别是标记和清除，为了避免程序本身运行给GC标记和清除带来不一致性，导致误删,为了保证一致性，golang会停止除了GC模块程序之外的程序运行，这个过程被称为STW。</li>
<li>标记垃圾方法
<ul>
<li>引用计数式
<ul>
<li>优点：
<ul>
<li>1、引用计数法可以在对象不活跃时（引用计数为0）立刻回收其内存。因此可以保证堆上时时刻刻都没有垃圾对象的存在（先不考虑循环引用导致无法回收的情况）。</li>
<li></li>
</ul>
2、引用计数法的最大暂停时间短。由于没有了独立的GC过程，而且不需要遍历整个堆来标记和清除对象，取而代之的是在对象引用计数为0时立即回收对象，这相当于将GC过程“分摊”到了每个对象上，不会有最大暂停时间特别长的情况发生。</li>
<li>劣势：
<ul>
<li>引用计数的增减开销在一些情况下会比较大，比如一些根引用的指针更新非常频繁，此时这种开销是不能忽视的。</li>
<li></li>
</ul>
<h2 id="另外对象引用计数器本身是需要空间的而计数器要占用多少位也是一个问题理论上系统内存可寻址的范围越大对象计数器占用的空间就要越大这样在一些小对象上就会出现计数器空间比对象本身的域还要大的情况内存空间利用率就会降低"><a class="header" href="#另外对象引用计数器本身是需要空间的而计数器要占用多少位也是一个问题理论上系统内存可寻址的范围越大对象计数器占用的空间就要越大这样在一些小对象上就会出现计数器空间比对象本身的域还要大的情况内存空间利用率就会降低">另外对象引用计数器本身是需要空间的，而计数器要占用多少位也是一个问题，理论上系统内存可寻址的范围越大，对象计数器占用的空间就要越大，这样在一些小对象上就会出现计数器空间比对象本身的域还要大的情况，内存空间利用率就会降低。</a></h2>
还有一个问题是循环引用的问题，假设两个对象A和B，A引用B，B也引用A，除此之外它们都没有其他引用关系了，这个时候A和B就形成了循环引用，变成一个“孤岛”，且它们的引用计数都是1，按照引用计数法的要求，它们将无法被回收，造成内存泄漏。</li>
</ul>
</li>
<li>追踪式
<ul>
<li>优点：
<ul>
<li>相对于引用计数算法，完全不必考虑环形引用问题。</li>
<li>操纵指针时没有额外的开销。</li>
<li>与用户程序完全分离。</li>
</ul>
</li>
<li>缺点：
<ul>
<li>标记清扫算法是非实时的，它要求在垃圾收集器运行时暂停用户程序运行，这对于实时和交互式系统的影响非常大。</li>
<li>基本的标记清扫算法通常在回收内存时会同时合并相邻空闲内存块，然而在系统运行一段时间后仍然难免会生成大量内存碎片，内存碎片意味着可用内存的总数量上足够但实际上不可用，同时还会增加分配内存的时间，降低内存访问的效率。</li>
<li>保守式的标记清扫算法可能会将某些无用对象当做存活对象，导致内存泄露。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="关键字-1"><a class="header" href="#关键字-1">关键字</a></h1>
<h2 id="package"><a class="header" href="#package">package</a></h2>
<p>package用于声明包的名称，需放在go文件所有代码的最前面。一个包由一个或多个go源文件组成，需放在同一个目录下，且同一个目录下的这些go文件的package的名字只能有一个</p>
<h2 id="import"><a class="header" href="#import">import</a></h2>
<p>用 import 关键字引入一个包，文件名不需要和包名一致</p>
<h2 id="var"><a class="header" href="#var">var</a></h2>
<p>使用var关键字是Go最基本的定义变量方式，有时也会使用到 := 来定义变量。</p>
<h2 id="const"><a class="header" href="#const">const</a></h2>
<p>const 用来声明一个常量，const 语句可以出现在任何 var 语句可以出现的地方，声明常量方式与 var 相同。const 声明的是常量，一旦创建，不可赋值修改。</p>
<h2 id="func"><a class="header" href="#func">func</a></h2>
<p>使用关键字 func 定义函数。其中，有返回值的函数，必须有明确的终止语句，否则会引发编译错误。函数是可变参的，变参的本质上是slice，只能有一个，且必须是最后一个。函数支持多返回值</p>
<h2 id="type"><a class="header" href="#type">type</a></h2>
<p>type是go语法里的重要而且常用的关键字，其主要作用就是用来定义类型。
类型等价定义，相当于类型重命名
定义接口</p>
<h2 id="struct"><a class="header" href="#struct">struct</a></h2>
<p>struct结构体是各个字段字段的类型的集合。是值类型，赋值和传参会赋值全部内容。</p>
<h2 id="interface"><a class="header" href="#interface">interface</a></h2>
<p>interface
用于定义接口。一个接口是一个方法集，如果一个类型实现了一个接口中的所有方法集，那么说明该类型实现此接口。接口类型变量可以存储任何实现了该接口的类型的值。特别的，interface{}表示空接口类型，默认地，所有类型均实现了空接口，所以interface{}可以接收任意类型值。</p>
<h2 id="map"><a class="header" href="#map">map</a></h2>
<p>map 用于声明映射变量。映射属容器类类型，是一个同种类型元素的无序组，通过唯一的键可以获取对应的值。可以使用 make 创建 map 变量，未初始化的映射值为 nil。创建map变量主要有如下几种方式：
//创建0容量的map
var map1 = make(map[T1] T2)
//创建指定容量的map，只是初始容量，会自动扩容
var map2 = make(map[T]T2, 10)
//创建并初始化map</p>
<pre><code>var map3 = map[string]int {
&quot;k1&quot; : 1,
&quot;k2&quot; : 2,
}
// 创建可以放任意值的map
var map4 = make(map[string]interface{})
</code></pre>
<h2 id="chan"><a class="header" href="#chan">chan</a></h2>
<p>chan用于声明channel（信道）。信道提供一种机制使两个并发执行的函数实现同步，并通过传递具体元素类型的值来通信。未初始化的信道值为 nil。</p>
<h2 id="go"><a class="header" href="#go">go</a></h2>
<p>go用于创建Go线程（goroutine），实现并发编程。Go程是与其它Go程并发运行在同一地址空间的函数，相比于线程与进程，它是轻量级的。Go程在多线程操作系统上可实现多路复用，因此若一个线程阻塞，比如说等待I/O，那么其它的线程就会运行。Go程的设计隐藏了线程创建和管理的诸多复杂性。
在函数或方法前添加 go 关键字能够在新的Go程中调用它。当调用完成后，该Go程也会安静地退出。效果有点像Unix Shell中的 &amp; 符号，它能让命令在后台运行。</p>
<h2 id="select"><a class="header" href="#select">select</a></h2>
<p>select 是 Go 中的一个控制结构，类似于用于通信的 switch 语句。每个 case 必须是一个通信操作，要么是发送要么是接收。select 随机执行一个可运行的 case。如果没有 case 可运行，它将阻塞，直到有 case
可运行。</p>
<h2 id="for"><a class="header" href="#for">for</a></h2>
<p>for是Go中唯一用于循环结构的关键词。有三个使用方式，分别是单个循环条件，经典的初始化/条件/后续形式，还有和range关键词结合使用来遍历容器类对象（数组、切片、映射）。</p>
<h2 id="range"><a class="header" href="#range">range</a></h2>
<p>同 for 一起使用，遍历对象</p>
<h2 id="break"><a class="header" href="#break">break</a></h2>
<p>break用于终止最内层的&quot;for&quot;、“switch&quot;或&quot;select&quot;语句的执行。</p>
<h2 id="continue"><a class="header" href="#continue">continue</a></h2>
<p>结合for一起使用，continue通常用于结束当前循环</p>
<h2 id="if"><a class="header" href="#if">if</a></h2>
<p>条件判断语句</p>
<h2 id="else"><a class="header" href="#else">else</a></h2>
<p>可省略条件表达式的括号；
支持初始化语句，可定义代码块局部变量；
if与else块中只有一条语句也需要添加大括号；
起始大括号必须与if与else同行。</p>
<h2 id="switch"><a class="header" href="#switch">switch</a></h2>
<p>switch语句提供多路执行</p>
<h2 id="case"><a class="header" href="#case">case</a></h2>
<p>case是switch和select分支条件</p>
<h2 id="default"><a class="header" href="#default">default</a></h2>
<p>所有的case分支都不满足时执行default分支</p>
<h2 id="fallthrough"><a class="header" href="#fallthrough">fallthrough</a></h2>
<p>使用fallthrough可以继续执行后面的case与default子句。</p>
<h2 id="defer"><a class="header" href="#defer">defer</a></h2>
<p>defer语句用于预设一个函数调用，即推迟函数的执行。 该函数会在执行 defer 的函数返回之前立即执行。它显得非比寻常， 但却是处理一些事情的有效方式，例如无论以何种路径返回，都必须释放资源的函数。
典型的例子就是解锁互斥和关闭文件。如果有多个defer 按照倒序执行。</p>
<h2 id="goto"><a class="header" href="#goto">goto</a></h2>
<p>goto用于将程序的执行转移到与其标签相应的语句。可以使用goto退出多层&quot;for&quot;、“switch&quot;或&quot;select”，功能类似于break携带标签。</p>
<h2 id="return"><a class="header" href="#return">return</a></h2>
<p>return用于函数执行的终止并可选地提供一个或多个返回值。 任何在函数F中被推迟的函数会在F 返回给其调用者前执行。函数可以通过return返回多个值。如果返回值在函数返回形参中指定了名字，那么return时可不带返回值列表。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="数据类型-1"><a class="header" href="#数据类型-1">数据类型</a></h1>
<h2 id="数字"><a class="header" href="#数字">数字</a></h2>
<h3 id="整形无符号"><a class="header" href="#整形无符号">整形无符号</a></h3>
<ul>
<li>uint8 无符号 8 位整型 (0 到 255)</li>
<li>uint16 无符号 16 位整型 (0 到 65535， 0到2的16次方-1)</li>
<li>uint32 无符号 32 位整型 (0 到 4294967295， 2的32次方-1)</li>
<li>uint64 无符号 64 位整型 (0 到 18446744073709551615， 2的64次方-1)</li>
</ul>
<h3 id="整形有符号"><a class="header" href="#整形有符号">整形有符号</a></h3>
<ul>
<li>int8 有符号 8 位整型 (-128 到 127)</li>
<li>int16 有符号 16 位整型 (-32768 到 32767， -2的15次方到2的15次方-1)</li>
<li>int32 有符号 32 位整型 (-2147483648 到 2147483647， -2的32次方到2的32次方-1)</li>
<li>int64 有符号 64 位整型 (-9223372036854775808 到 9223372036854775807， -2的64次方到2的64次方-1)</li>
</ul>
<h3 id="浮点型"><a class="header" href="#浮点型">浮点型</a></h3>
<ul>
<li>float32 IEEE-754 32位浮点型数(支持6位有效数字（精确位数，超出范围后，会有误差）,最大值为3.4e38，可以用math包中的math.MaxFloat32表示)</li>
<li>float64 IEEE-754 64位浮点型数(支持15位有效数字（精确位数，超出范围后，会有误差）,最大值为1.8e308，math.MaxFolat64表示)</li>
<li>complex64 32 位实数和虚数</li>
<li>complex128 64 位实数和虚数</li>
</ul>
<h3 id="其他数字类型"><a class="header" href="#其他数字类型">其他数字类型</a></h3>
<ul>
<li>byte 类似uint8</li>
<li>Rune 类似 int32</li>
<li>uint 32或64（64位系统默认64，32位系统默认32）</li>
<li>int 32或者64（64位系统默认64，32位系统默认32）</li>
<li>uintptr 无符号整型，用于存放一个指针</li>
</ul>
<h2 id="布尔值待补充"><a class="header" href="#布尔值待补充">布尔值（待补充）</a></h2>
<h2 id="字符串待补充"><a class="header" href="#字符串待补充">字符串（待补充）</a></h2>
<h2 id="数组待补充"><a class="header" href="#数组待补充">数组（待补充）</a></h2>
<h2 id="结构体待补充"><a class="header" href="#结构体待补充">结构体（待补充）</a></h2>
<h2 id="指针待补充"><a class="header" href="#指针待补充">指针（待补充）</a></h2>
<h2 id="切片待补充"><a class="header" href="#切片待补充">切片（待补充）</a></h2>
<h2 id="map待补充"><a class="header" href="#map待补充">map（待补充）</a></h2>
<p>map声明的时候默认值是nil ，此时进行取值，返回的是对应类型的零值（不存在也是返回零值）。
因此想要正常的使用map，必须要对其进行初始化。否则在使用时会panic.</p>
<pre><code>m := make(map[string]string)
//or
m := map[string]string{
&quot;one&quot; : &quot;golang&quot;,
&quot;two&quot; : &quot;c&quot;,
&quot;three&quot; : &quot;java&quot;,
}
</code></pre>
<p>基本操作</p>
<pre><code>增
m[&quot;one&quot;] = &quot;golang&quot;

删
删除map需要使用delete()函数，第一个参数是要操作的map，第二参数是该map中要删除的数据的key.
delete(m, &quot;one&quot;)

改
m[&quot;one&quot;] = &quot;go&quot;

查
查询时，map会返回两个值，第一个是key对应的value，第二个是布尔值，如果查询到数据则为true，没有查询到则为false。当然也可以忽略掉第二个值，仅获取value。
i := m[&quot;name&quot;]
i, ok := m[&quot;name&quot;]
_, ok := m[&quot;name&quot;]

遍历
map的数据是无序的，遍历时输出的结果与插入的顺序是不同的。如果需要有序的遍历map，需要先获取map的所有key，然后进行排序，最后进行遍历。
var keys []string
for k, _ := range m {
    keys = append(keys, k)
}
// 进行数组的排序
sort.Strings(keys)
for _, k := range keys {
    fmt.Println(k, m[k])
}
</code></pre>
<h2 id="函数待补充"><a class="header" href="#函数待补充">函数（待补充）</a></h2>
<h2 id="通道待补充"><a class="header" href="#通道待补充">通道（待补充）</a></h2>
<h2 id="接口待补充"><a class="header" href="#接口待补充">接口（待补充）</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="原生模块"><a class="header" href="#原生模块">原生模块</a></h1>
<h2 id="context-1"><a class="header" href="#context-1">context</a></h2>
<p>context.Context 是golang中独特的涉及,可以用来用来设置截止日期、同步信号，传递请求相关值的结构体。 与 Goroutine 有比较密切的关系。</p>
<ul>
<li>Deadline方法是获取设置的截止时间的意思，第一个返回值是截止时间，到了这个时间点，Context会自动发起取消请求； 第二个返回值ok==false时表示没有设置截止时间，如果需要取消的话，需要调用取消函数进行取消。</li>
<li>Done方法返回一个只读的chan，类型为struct{}，在goroutine中，如果该方法返回的chan可以读取，则意味着parent context已经发起了取消请求，
我们通过Done方法收到这个信号后，就应该做清理操作，然后退出goroutine，释放资源。之后，Err 方法会返回一个错误，告知为什么 Context 被取消。</li>
<li>Err方法返回取消的错误原因，因为什么Context被取消。</li>
<li>Value方法获取该Context上绑定的值，是一个键值对，通过一个Key才可以获取对应的值，这个值一般是线程安全的。</li>
</ul>
<p>生成context的几种方法</p>
<ul>
<li>TODO() Context</li>
<li>Background() Context</li>
<li>WithValue(parent Context, key, val interface{}) Context</li>
</ul>
<p>生成context和CancelFunc的几种方法</p>
<ul>
<li>WithCancel(parent Context) (ctx Context, cancel CancelFunc)</li>
<li>WithDeadline(parent Context, d time.Time) (Context, CancelFunc)</li>
<li>WithTimeout(parent Context, timeout time.Duration) (Context, CancelFunc)</li>
</ul>
<h2 id="fmt"><a class="header" href="#fmt">fmt</a></h2>
<ul>
<li>Println(a ...interface{}) (n int, err error):输出至控制台，两个变量中间有空格符，末尾带换行符;返回值n，包含空格符和换行符</li>
<li>Print(a ...interface{}) (n int, err error):输出至控制台，变量中存在字符串时前后变量与字符串无空格符，末尾不带换行符</li>
<li>Printf(format string, a ...interface{}) (n int, err error):格式化输出至控制台，末尾不带换行符</li>
<li>Sprintf(format string, a ...interface{}) string:不输出控制台，格式化输出，末尾不带换行符</li>
<li>Sprint(a ...interface{}) string:不输出控制台，变量中存在字符串时前后变量与字符串无空格符，末尾不带换行符</li>
<li>Sprintln(a ...interface{}) string:不输出控制台，两个变量中间有空格符,末尾带换行符</li>
</ul>
<h2 id="sort"><a class="header" href="#sort">sort</a></h2>
<ul>
<li>Strings(x []string) { Sort(StringSlice(x)) }:字符串排序，从第一位开始比对，a-z,0-9</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="kubebuilder"><a class="header" href="#kubebuilder">kubebuilder</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="kubernetes-csi"><a class="header" href="#kubernetes-csi">kubernetes-csi</a></h1>
<h2 id="参考资料"><a class="header" href="#参考资料">参考资料</a></h2>
<p><a href="https://kubernetes-csi.github.io/docs/csi-proxy.html">https://kubernetes-csi.github.io/docs/csi-proxy.html</a></p>
<p>示例：<a href="programming_language/golang/kubernetes-csi/example-20220726.tar.gz">d71ae71e66d55e9003bd7ae4d5c01d05</a></p>
<h2 id="sidecar-containers"><a class="header" href="#sidecar-containers">Sidecar Containers</a></h2>
<table><thead><tr><th>名称</th><th>用途</th></tr></thead><tbody>
<tr><td>external-provisioner</td><td>用于监视VolumeAttachment对象的Kubernetes API服务器，并针对CSI端点触发Controller[Publish</td></tr>
<tr><td>external-attacher</td><td>用于监视PersistentVolumeClaim对象的Kubernetes API服务器</td></tr>
<tr><td>external-snapshotter</td><td>从测试版开始，快照控制器将监视Kubernetes API服务器上的VolumeSnapshot和VolumeSnapshotContent CRD对象。CSI外部snapshotter侧车仅监视Kubernetes API服务器上的VolumeSnapshotContent CRD对象。CSI外部snapshotter侧车还负责调用CSI RPC CreateSnapshot、DeleteSnapshot和ListSnapshot。</td></tr>
<tr><td>external-resizer</td><td>监视Kubernetes API服务器对CSI端点进行编辑并触发ControllerExpandVolume操作</td></tr>
<tr><td>node-driver-registrar</td><td>用于从CSI端点获取驱动程序信息（使用NodeGetInfo），并使用kubelet插件注册机制在该节点上的kubelet中注册</td></tr>
<tr><td>cluster-driver-registrar (deprecated)</td><td>通过创建一个CSIDriver对象将CSI驱动程序与Kubernetes集群注册，该对象使驱动程序能够自定义Kubernetes与它交互的方式,从Kubernetes 1.16开始，这个侧车集装箱被正式弃用</td></tr>
<tr><td>livenessprobe</td><td>用于监控CSI驱动程序的健康状况，并通过Liveness Probe机制向Kubernetes报告</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h1 id="问题"><a class="header" href="#问题">问题</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="数组和列表的区别"><a class="header" href="#数组和列表的区别">数组和列表的区别</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="activemq"><a class="header" href="#activemq">activemq</a></h1>
<p>编写及更新时间2022/06/24，分布式key-value存储系统</p>
<h2 id="参考"><a class="header" href="#参考">参考</a></h2>
<ul>
<li><a href="https://activemq.apache.org">官网</a></li>
<li><a href="https://github.com/apache/activemq">源码</a></li>
</ul>
<h2 id="目录"><a class="header" href="#目录">目录</a></h2>
<ul>
<li><a href="server_component/activemq/index.html#%E9%85%8D%E7%BD%AE">配置</a></li>
<li><a href="server_component/activemq/index.html#%E6%95%85%E9%9A%9C">故障</a>
<ul>
<li><a href="server_component/activemq/index.html#%E5%BC%82%E5%B8%B8">io异常</a></li>
</ul>
</li>
</ul>
<h3 id="配置"><a class="header" href="#配置">配置</a></h3>
<h3 id="故障"><a class="header" href="#故障">故障</a></h3>
<h4 id="异常"><a class="header" href="#异常">异常</a></h4>
<p>数据落盘导致</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ceph"><a class="header" href="#ceph">ceph</a></h1>
<h2 id="常用命令"><a class="header" href="#常用命令">常用命令</a></h2>
<h3 id="查询"><a class="header" href="#查询">查询</a></h3>
<ul>
<li>基础查看</li>
</ul>
<pre><code>ceph status
ceph health detail
ceph df
ceph osd status
ceph osd df
</code></pre>
<h3 id="数据均衡"><a class="header" href="#数据均衡">数据均衡</a></h3>
<h4 id="业务优先"><a class="header" href="#业务优先">业务优先</a></h4>
<pre><code>ceph tell osd.* injectargs '--osd-max-backfills 1 --osd-recovery-max-active 1 --osd-recovery-max-single-start 1'
ceph tell osd.* injectargs '--osd-recovery-sleep 1'
</code></pre>
<h4 id="恢复优先"><a class="header" href="#恢复优先">恢复优先</a></h4>
<pre><code>ceph tell osd.* injectargs '--osd-max-backfills 128 --osd-recovery-max-active 64 --osd-recovery-max-single-start 64'
ceph tell osd.* injectargs '--osd-recovery-sleep 0'
</code></pre>
<h4 id="还原配置"><a class="header" href="#还原配置">还原配置</a></h4>
<pre><code>ceph tell osd.* injectargs '--osd-max-backfills 1 --osd-recovery-max-active 3 --osd-recovery-max-single-start 1'
ceph tell osd.* injectargs '--osd-recovery-sleep 0'
</code></pre>
<h3 id="限制数据"><a class="header" href="#限制数据">限制数据</a></h3>
<h4 id="osd-限制数据量"><a class="header" href="#osd-限制数据量">osd 限制数据量</a></h4>
<pre><code>ceph osd reweight 19 0.9
</code></pre>
<h4 id="数据填充"><a class="header" href="#数据填充">数据填充</a></h4>
<pre><code>ceph osd set nobackfill
ceph osd unset nobackfill
</code></pre>
<h4 id="数据回复"><a class="header" href="#数据回复">数据回复</a></h4>
<pre><code>ceph osd set norecover
ceph osd unset norecover
</code></pre>
<h4 id="副本限制"><a class="header" href="#副本限制">副本限制</a></h4>
<pre><code>ceph osd pool get bigstorage size
ceph osd pool set bigstorage size 2
</code></pre>
<h4 id="pg数量限制"><a class="header" href="#pg数量限制">pg数量限制</a></h4>
<pre><code>ceph osd pool set bigstorage pg_num 1024
ceph osd pool get bigstorage pg_num
ceph osd pool set bigstorage pgp_num 1024
ceph osd pool get bigstorage pgp_num
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="etcd-1"><a class="header" href="#etcd-1">etcd</a></h1>
<p>编写及更新时间2022/02/23，分布式key-value存储系统，当前版本v2/v3</p>
<h2 id="介绍"><a class="header" href="#介绍">介绍</a></h2>
<ul>
<li><a href="https://etcd.io">官网</a></li>
<li><a href="https://etcd.cn">中文官网</a></li>
<li><a href="https://github.com/etcd-io/etcd/releases">源码</a></li>
</ul>
<h2 id="功能及操作"><a class="header" href="#功能及操作">功能及操作</a></h2>
<ul>
<li>功能</li>
<li>操作
<ul>
<li>put/get/delete（基本操作）</li>
<li>watch（监听）</li>
<li>lease（租约）</li>
<li>op操作</li>
</ul>
</li>
</ul>
<h2 id="语言模块"><a class="header" href="#语言模块">语言模块</a></h2>
<ul>
<li>golang
<ul>
<li>go.etcd.io/etcd/clientv3</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="kafka"><a class="header" href="#kafka">kafka</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mongo"><a class="header" href="#mongo">mongo</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mysql"><a class="header" href="#mysql">mysql</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rabbitmq"><a class="header" href="#rabbitmq">rabbitmq</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="redis"><a class="header" href="#redis">redis</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tdsql"><a class="header" href="#tdsql">tdsql</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ansible"><a class="header" href="#ansible">ansible</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="jenkins"><a class="header" href="#jenkins">jenkins</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="kustomize"><a class="header" href="#kustomize">kustomize</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mdbook"><a class="header" href="#mdbook">mdbook</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cicd"><a class="header" href="#cicd">ci/cd</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cicd-1"><a class="header" href="#cicd-1">ci/cd</a></h1>

                    </main>
                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>
        <div style="text-align: center"><a href="https://beian.miit.gov.cn/" target="_blank">湘ICP备2022014918号-1</a></div>

        <!-- Livereload script (if served using the cli tool) -->
        <script type="text/javascript">
            var socket = new WebSocket("ws://0.0.0.0:3000/__livereload");
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
    </body>

</html>
